/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var spin_wheel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! spin-wheel */ \"./node_modules/spin-wheel/src/wheel.js\");\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  var container = document.querySelector('.wheel-container');\n  var wheel; // Declare the wheel variable here to be accessible throughout\n  var colorScheme = ['#FF5733', '#33FF57', '#3357FF', '#F033FF', '#FF33F6'];\n  document.getElementById('wheelForm').addEventListener('submit', function (event) {\n    event.preventDefault();\n    var names = document.getElementById('itemNames').value.split('\\n').filter(Boolean);\n    var items = names.map(function (name, index) {\n      return {\n        label: name.trim(),\n        backgroundColor: colorScheme[index % colorScheme.length]\n      };\n    });\n\n    // Ensure the wheel is created here with the new items\n    container.innerHTML = ''; // Clear previous wheel, if any\n    wheel = new spin_wheel__WEBPACK_IMPORTED_MODULE_0__.Wheel(container, {\n      items: items\n    });\n    console.log('Wheel initialized', wheel);\n  }); // Ensure this closing bracket matches with the opening bracket of the event listener\n\n  document.getElementById('spinButton').addEventListener('click', function () {\n    console.log('Spin button clicked');\n    if (!wheel) {\n      console.log('Wheel not initialized');\n      alert(\"Please create the wheel first by submitting the form.\");\n      return;\n    }\n    var initialSpeed = 700 + Math.random() * 200; // Initial speed between 20 and 30\n\n    var duration = 10000;\n    console.log('Spinning wheel...');\n    wheel.spin(initialSpeed, duration);\n    setTimeout(function () {\n      var winnerIndex = wheel.getCurrentIndex();\n      console.log(\"Winner index: \".concat(winnerIndex));\n      alert(\"The winner is: \".concat(wheel.items[winnerIndex].label, \"!\"));\n    }, duration);\n  }); // Ensure this closing bracket matches with the opening bracket of the event listener\n}); // Ensure this closing bracket matches with the opening bracket of the 'DOMContentLoaded' event listener\n\n//# sourceURL=webpack://my-spin-wheel-project/./src/index.js?");

/***/ }),

/***/ "./node_modules/spin-wheel/src/constants.js":
/*!**************************************************!*\
  !*** ./node_modules/spin-wheel/src/constants.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlignText: () => (/* binding */ AlignText),\n/* harmony export */   Debugging: () => (/* binding */ Debugging),\n/* harmony export */   Defaults: () => (/* binding */ Defaults),\n/* harmony export */   arcAdjust: () => (/* binding */ arcAdjust),\n/* harmony export */   baseCanvasSize: () => (/* binding */ baseCanvasSize),\n/* harmony export */   dragCapturePeriod: () => (/* binding */ dragCapturePeriod)\n/* harmony export */ });\n/**\n * Adjustment when drawing arcs to ensure 0° is north (due to canvas drawing arcs from 90°).\n */\nconst arcAdjust = -90;\n\nconst baseCanvasSize = 500; // 500 seemed to be a good value for this.\n\n/**\n * The period in milliseconds that we record drag events.\n * Used to calculate how fast the wheel should spin after the drag ends.\n * For example, if the wheel was dragged 20 degrees over the last 250ms,\n * then it should continue rotating at a speed of 20 degrees every 250ms after the drag ends.\n */\nconst dragCapturePeriod = 250;\n\n/**\n * Text alignment enum.\n */\nconst AlignText = Object.freeze({\n  left: 'left',\n  right: 'right',\n  center: 'center',\n});\n\n/**\n * Wheel property defaults.\n */\nconst Defaults = Object.freeze({\n  wheel: {\n    borderColor: '#000',\n    borderWidth: 1,\n    debug: false,\n    image: null,\n    isInteractive: true,\n    itemBackgroundColors: ['#fff'],\n    itemLabelAlign: AlignText.right,\n    itemLabelBaselineOffset: 0,\n    itemLabelColors: ['#000'],\n    itemLabelFont: 'sans-serif',\n    itemLabelFontSizeMax: baseCanvasSize,\n    itemLabelRadius: 0.85,\n    itemLabelRadiusMax: 0.2,\n    itemLabelRotation: 0,\n    itemLabelStrokeColor: '#fff',\n    itemLabelStrokeWidth: 0,\n    items: [],\n    lineColor: '#000',\n    lineWidth: 1,\n    pixelRatio: 0,\n    radius: 0.95,\n    rotation: 0,\n    rotationResistance: -35,\n    rotationSpeedMax: 300,\n    offset: {w: 0, h: 0},\n    onCurrentIndexChange: null,\n    onRest: null,\n    onSpin: null,\n    overlayImage: null,\n    pointerAngle: 0,\n  },\n  item: {\n    backgroundColor: null,\n    image: null,\n    imageOpacity: 1,\n    imageRadius: 0.5,\n    imageRotation: 0,\n    imageScale: 1,\n    label: '',\n    labelColor: null,\n    value: null,\n    weight: 1,\n  },\n});\n\nconst Debugging = Object.freeze({\n  pointerLineColor: '#ff00ff',\n  labelOutlineColor: '#ff00ff',\n  labelRadiusColor: '#00ff00',\n  dragEventHue: 200,\n});\n\n\n//# sourceURL=webpack://my-spin-wheel-project/./node_modules/spin-wheel/src/constants.js?");

/***/ }),

/***/ "./node_modules/spin-wheel/src/events.js":
/*!***********************************************!*\
  !*** ./node_modules/spin-wheel/src/events.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   register: () => (/* binding */ register),\n/* harmony export */   unregister: () => (/* binding */ unregister)\n/* harmony export */ });\nfunction register(wheel = {}) {\n\n  registerPointerEvents(wheel);\n\n  // Listen for when the window is resized.\n  wheel._handler_onResize = e => wheel.resize(e);\n  window.addEventListener('resize', wheel._handler_onResize);\n\n  // Listen for when window.devicePixelRatio changes.\n  // For example, when the browser window is moved to a different screen.\n  // Note: Chrome Version 116 raises the `resize` event when `window.devicePixelRatio` changes,\n  // and so does Firefox 117 but sometimes it raises it twice (shrug).\n  // However Safari 16.3 doesn't, hence we need to monitor this separately.\n  const listenForDevicePixelRatioChange = () => {\n    wheel._mediaQueryList = window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\n    wheel._mediaQueryList.addEventListener('change', wheel._handler_onDevicePixelRatioChange, { once: true });\n  };\n  wheel._handler_onDevicePixelRatioChange = () => {\n    wheel.resize();\n    listenForDevicePixelRatioChange();\n  };\n  listenForDevicePixelRatioChange();\n}\n\nfunction unregister(wheel = {}) {\n\n  const canvas = wheel.canvas;\n\n  if ('PointerEvent' in window) {\n    canvas.removeEventListener('pointerdown', wheel._handler_onPointerDown);\n    canvas.removeEventListener('pointermove', wheel._handler_onPointerMoveRefreshCursor);\n  } else {\n    canvas.removeEventListener('touchstart', wheel._handler_onTouchStart);\n    canvas.removeEventListener('mousedown', wheel._handler_onMouseDown);\n    canvas.removeEventListener('mousemove', wheel._handler_onMouseMoveRefreshCursor);\n  }\n\n  window.removeEventListener('resize', wheel._handler_onResize);\n  wheel._mediaQueryList.removeEventListener('change', wheel._handler_onDevicePixelRatioChange);\n\n}\n\nfunction registerPointerEvents(wheel = {}) {\n  // Adapted from https://glitch.com/~jake-in-the-box\n\n  const canvas = wheel.canvas;\n\n  wheel._handler_onPointerMoveRefreshCursor = (e = {}) => {\n    const point = {\n      x: e.clientX,\n      y: e.clientY,\n    };\n    wheel._isCursorOverWheel = wheel.wheelHitTest(point);\n    wheel.refreshCursor();\n  };\n\n  wheel._handler_onMouseMoveRefreshCursor = (e = {}) => {\n    const point = {\n      x: e.clientX,\n      y: e.clientY,\n    };\n    wheel._isCursorOverWheel = wheel.wheelHitTest(point);\n    wheel.refreshCursor();\n  };\n\n  wheel._handler_onPointerDown = (e = {}) => {\n\n    const point = {\n      x: e.clientX,\n      y: e.clientY,\n    };\n\n    if (!wheel.isInteractive) return;\n    if (!wheel.wheelHitTest(point)) return;\n\n    e.preventDefault();\n    wheel.dragStart(point);\n    canvas.setPointerCapture(e.pointerId);\n    canvas.addEventListener('pointermove', onPointerMove);\n    canvas.addEventListener('pointerup', onPointerUp);\n    canvas.addEventListener('pointercancel', onPointerUp);\n    canvas.addEventListener('pointerout', onPointerUp);\n\n    function onPointerMove(e = {}) {\n      e.preventDefault();\n      wheel.dragMove({\n        x: e.clientX,\n        y: e.clientY,\n      });\n    }\n\n    function onPointerUp(e = {}) {\n      e.preventDefault();\n      canvas.releasePointerCapture(e.pointerId);\n      canvas.removeEventListener('pointermove', onPointerMove);\n      canvas.removeEventListener('pointerup', onPointerUp);\n      canvas.removeEventListener('pointercancel', onPointerUp);\n      canvas.removeEventListener('pointerout', onPointerUp);\n      wheel.dragEnd();\n    }\n\n  };\n\n  wheel._handler_onMouseDown = (e = {}) => {\n\n    const point = {\n      x: e.clientX,\n      y: e.clientY,\n    };\n\n    if (!wheel.isInteractive) return;\n    if (!wheel.wheelHitTest(point)) return;\n\n    wheel.dragStart(point);\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n\n    function onMouseMove(e = {}) {\n      e.preventDefault();\n      wheel.dragMove({\n        x: e.clientX,\n        y: e.clientY,\n      });\n    }\n\n    function onMouseUp(e = {}) {\n      e.preventDefault();\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n      wheel.dragEnd();\n    }\n\n  };\n\n  wheel._handler_onTouchStart = (e = {}) => {\n\n    const point = {\n      x: e.targetTouches[0].clientX,\n      y: e.targetTouches[0].clientY,\n    };\n\n    if (!wheel.isInteractive) return;\n    if (!wheel.wheelHitTest(point)) return;\n\n    e.preventDefault();\n    wheel.dragStart(point);\n    canvas.addEventListener('touchmove', onTouchMove);\n    canvas.addEventListener('touchend', onTouchEnd);\n    canvas.addEventListener('touchcancel', onTouchEnd);\n\n    function onTouchMove(e = {}) {\n      e.preventDefault();\n      wheel.dragMove({\n        x: e.targetTouches[0].clientX,\n        y: e.targetTouches[0].clientY,\n      });\n    }\n\n    function onTouchEnd(e = {}) {\n      e.preventDefault();\n      canvas.removeEventListener('touchmove', onTouchMove);\n      canvas.removeEventListener('touchend', onTouchEnd);\n      canvas.removeEventListener('touchcancel', onTouchEnd);\n      wheel.dragEnd();\n    }\n\n  };\n\n  if ('PointerEvent' in window) {\n    canvas.addEventListener('pointerdown', wheel._handler_onPointerDown);\n    canvas.addEventListener('pointermove', wheel._handler_onPointerMoveRefreshCursor);\n  } else {\n    canvas.addEventListener('touchstart', wheel._handler_onTouchStart);\n    canvas.addEventListener('mousedown', wheel._handler_onMouseDown);\n    canvas.addEventListener('mousemove', wheel._handler_onMouseMoveRefreshCursor);\n  }\n\n}\n\n//# sourceURL=webpack://my-spin-wheel-project/./node_modules/spin-wheel/src/events.js?");

/***/ }),

/***/ "./node_modules/spin-wheel/src/item.js":
/*!*********************************************!*\
  !*** ./node_modules/spin-wheel/src/item.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Item: () => (/* binding */ Item)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/spin-wheel/src/util.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/spin-wheel/src/constants.js\");\n\n\n\nclass Item {\n\n  constructor(wheel, props = {}) {\n\n    // Validate params.\n    if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject(wheel)) throw new Error('wheel must be an instance of Wheel'); // Ideally we would use instanceof, however importing the Wheel class would create a circular ref.\n    if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject(props) && props !== null) throw new Error('props must be an Object or null');\n\n    this._wheel = wheel;\n\n    // Assign default values.\n    // This avoids null exceptions when we initalise each property one-by-one in `init()`.\n    for (const i of Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item)) {\n      this['_' + i] = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item[i];\n    }\n\n    if (props) {\n      this.init(props);\n    } else {\n      this.init(_constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item);\n    }\n\n  }\n\n  /**\n   * Initialise all properties.\n   */\n  init(props = {}) {\n    this.backgroundColor = props.backgroundColor;\n    this.image = props.image;\n    this.imageOpacity = props.imageOpacity;\n    this.imageRadius = props.imageRadius;\n    this.imageRotation = props.imageRotation;\n    this.imageScale = props.imageScale;\n    this.label = props.label;\n    this.labelColor = props.labelColor;\n    this.value = props.value;\n    this.weight = props.weight;\n  }\n\n  /**\n   * The background color of the item.\n   * When `null`, the actual color rendered will fall back to `Wheel.itemBackgroundColors`.\n   * Example: `'#fff'`.\n   */\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  set backgroundColor(val) {\n    if (typeof val === 'string') {\n      this._backgroundColor = val;\n    } else {\n      this._backgroundColor = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.backgroundColor;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The url of an image that will be drawn on the item.\n   * Any part of the image that extends outside the item will be clipped.\n   * The image will be drawn over the top of `Item.backgroundColor`.\n   */\n  get image() {\n    return this._image;\n  }\n  set image(val) {\n    let img;\n    if (typeof val === 'string') {\n      img = new Image();\n      img.src = val;\n      img.onload = e => this._wheel.refresh();\n    } else {\n      img = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.image;\n    }\n    this._image = img;\n    this._wheel.refresh();\n  }\n\n  /**\n   * The opacity (as a percent) of `Item.image`.\n   * Useful if you want to fade the image to make the item's label stand out.\n   */\n  get imageOpacity() {\n    return this._imageOpacity;\n  }\n  set imageOpacity(val) {\n    if (typeof val === 'number') {\n      this._imageOpacity = val;\n    } else {\n      this._imageOpacity = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.imageOpacity;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The point along the radius (as a percent, starting from the center of the wheel) to draw the center of `Item.image`.\n   */\n  get imageRadius() {\n    return this._imageRadius;\n  }\n  set imageRadius(val) {\n    if (typeof val === 'number') {\n      this._imageRadius = val;\n    } else {\n      this._imageRadius = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.imageRadius;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The rotation (angle in degrees) of `Item.image`.\n   */\n  get imageRotation() {\n    return this._imageRotation;\n  }\n  set imageRotation(val) {\n    if (typeof val === 'number') {\n      this._imageRotation = val;\n    } else {\n      this._imageRotation = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.imageRotation;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The scale (as a percent) to resize `Item.image`.\n   */\n  get imageScale() {\n    return this._imageScale;\n  }\n  set imageScale(val) {\n    if (typeof val === 'number') {\n      this._imageScale = val;\n    } else {\n      this._imageScale = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.imageScale;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The text that will be drawn on the item.\n   */\n  get label() {\n    return this._label;\n  }\n  set label(val) {\n    if (typeof val === 'string') {\n      this._label = val;\n    } else {\n      this._label = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.label;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The color of the label.\n   * When `null`, the actual color rendered will fall back to `Wheel.itemLabelColors`.\n   * Example: `'#000'`.\n   */\n  get labelColor() {\n    return this._labelColor;\n  }\n  set labelColor(val) {\n    if (typeof val === 'string') {\n      this._labelColor = val;\n    } else {\n      this._labelColor = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.labelColor;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * Some value that has meaning to your application.\n   * For example, a reference to the object representing the item on the wheel, or a database id.\n   */\n  get value() {\n    return this._value;\n  }\n  set value(val) {\n    if (val !== undefined) {\n      this._value = val;\n    } else {\n      this._value = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.value;\n    }\n  }\n\n  /**\n   * The proportional size of the item relative to other items on the wheel.\n   * For example, if you have 2 items where `item[0]` has a weight of `1` and `item[1]` has a weight of `2`,\n   * then `item[0]` will take up 1/3 of the space on the wheel.\n   */\n  get weight() {\n    return this._weight;\n  }\n  set weight(val) {\n    if (typeof val === 'number') {\n      this._weight = val;\n    } else {\n      this._weight = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.item.weight;\n    }\n  }\n\n  /**\n   * Get the 0-based index of this item.\n   */\n  getIndex() {\n    const index = this._wheel.items.findIndex(i => i === this);\n    if (index === -1) throw new Error('Item not found in parent Wheel');\n    return index;\n  }\n\n  /**\n   * Get the angle (in degrees) that this item ends at (exclusive), ignoring the current `rotation` of the wheel.\n   */\n  getCenterAngle() {\n    const angle = this._wheel.getItemAngles()[ this.getIndex() ];\n    return angle.start + ((angle.end - angle.start) / 2);\n  }\n\n  /**\n   * Get the angle (in degrees) that this item starts at (inclusive), ignoring the current `rotation` of the wheel.\n   */\n  getStartAngle() {\n    return this._wheel.getItemAngles()[ this.getIndex() ].start;\n  }\n\n  /**\n   * Get the angle (in degrees) that this item ends at (inclusive), ignoring the current `rotation` of the wheel.\n   */\n  getEndAngle() {\n    return this._wheel.getItemAngles()[ this.getIndex() ].end;\n  }\n\n  /**\n   * Return a random angle (in degrees) between this item's start angle (inclusive) and end angle (inclusive).\n   */\n  getRandomAngle() {\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.getRandomFloat(this.getStartAngle(), this.getEndAngle());\n  }\n\n}\n\n\n//# sourceURL=webpack://my-spin-wheel-project/./node_modules/spin-wheel/src/item.js?");

/***/ }),

/***/ "./node_modules/spin-wheel/src/util.js":
/*!*********************************************!*\
  !*** ./node_modules/spin-wheel/src/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addAngle: () => (/* binding */ addAngle),\n/* harmony export */   aveArray: () => (/* binding */ aveArray),\n/* harmony export */   calcWheelRotationForTargetAngle: () => (/* binding */ calcWheelRotationForTargetAngle),\n/* harmony export */   degRad: () => (/* binding */ degRad),\n/* harmony export */   diffAngle: () => (/* binding */ diffAngle),\n/* harmony export */   easeSinOut: () => (/* binding */ easeSinOut),\n/* harmony export */   fixFloat: () => (/* binding */ fixFloat),\n/* harmony export */   getAngle: () => (/* binding */ getAngle),\n/* harmony export */   getDistanceBetweenPoints: () => (/* binding */ getDistanceBetweenPoints),\n/* harmony export */   getFontSizeToFit: () => (/* binding */ getFontSizeToFit),\n/* harmony export */   getMouseButtonsPressed: () => (/* binding */ getMouseButtonsPressed),\n/* harmony export */   getRandomFloat: () => (/* binding */ getRandomFloat),\n/* harmony export */   getRandomInt: () => (/* binding */ getRandomInt),\n/* harmony export */   isAngleBetween: () => (/* binding */ isAngleBetween),\n/* harmony export */   isImageLoaded: () => (/* binding */ isImageLoaded),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPointInCircle: () => (/* binding */ isPointInCircle),\n/* harmony export */   setProp: () => (/* binding */ setProp),\n/* harmony export */   translateXYToElement: () => (/* binding */ translateXYToElement)\n/* harmony export */ });\n/**\n * Get a random integer between `min` (inclusive) and `max` (exclusive).\n */\nfunction getRandomInt(min = 0, max = 0) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n/**\n * Get a random number between `min` (inclusive) and `max` (inclusive).\n * Control the number of decimal places with `round`.\n */\nfunction getRandomFloat(min = 0, max = 0, round = 14) {\n  return parseFloat((Math.random() * (max - min) + min).toFixed(round));\n}\n\n/**\n * Convert degrees to radians.\n */\nfunction degRad(degrees = 0) {\n  return degrees * Math.PI / 180;\n}\n\n/**\n * Return true if `angle` is between `arcStart` (inclusive) and `arcEnd` (exclusive).\n * Example: `(0, 359, 1) == true`\n * Example: `(0, 1, 2) == false`\n */\nfunction isAngleBetween(angle, arcStart, arcEnd) {\n  if (arcStart < arcEnd) return arcStart <= angle && angle < arcEnd;\n  return arcStart <= angle || angle < arcEnd;\n}\n\n/**\n * Average the values in `array`.\n * Only operate on truthy values.\n * Truthy values that are not Numbers count as 1.\n * Return 0 if the array is empty.\n */\nfunction aveArray(array = []) {\n  let sum = 0;\n  for (const val of array) {\n    if (val) sum += ((typeof val === 'number') ? val : 1);\n  }\n  return sum / array.length || 0;\n}\n\n/**\n * Calculate the largest font size that `text` can have without exceeding `maxWidth`.\n * Won't work unless `fontFamily` has been loaded.\n */\nfunction getFontSizeToFit(text, fontFamily, maxWidth, canvasContext) {\n  canvasContext.save();\n  canvasContext.font = `1px ${fontFamily}`;\n  const w = canvasContext.measureText(text).width;\n  canvasContext.restore();\n  return maxWidth / w;\n}\n\n/**\n * Return true if the given point is inside a circle.\n * cx, cy is circle center.\n * radius is circle radius.\n */\nfunction isPointInCircle(point = {x: 0, y: 0}, cx, cy, radius) {\n  const distanceSquared = ((point.x - cx) ** 2) + ((point.y - cy) ** 2);\n  return distanceSquared <= (radius ** 2);\n}\n\n/**\n * Translate the given point from the viewport's coordinate space to the element's coordinate space.\n */\nfunction translateXYToElement(point = {x: 0, y: 0}, element = {}, devicePixelRatio = 1) {\n  const rect = element.getBoundingClientRect();\n  return {\n    x: (point.x - rect.left) * devicePixelRatio,\n    y: (point.y - rect.top) * devicePixelRatio,\n  };\n}\n\nfunction getMouseButtonsPressed(event = {}) {\n  return [1, 2, 4, 8, 16].filter(i => event.buttons & i);\n}\n\n/**\n * Source: https://stackoverflow.com/a/47653643/737393\n */\nfunction getAngle(originX, originY, targetX, targetY) {\n    const dx = originX - targetX;\n    const dy = originY - targetY;\n\n    let theta = Math.atan2(-dy, -dx);\n    theta *= 180 / Math.PI;\n    if (theta < 0) theta += 360;\n\n    return theta;\n}\n\n/**\n * Return the distance between two points.\n */\nfunction getDistanceBetweenPoints(point1 = {x: 0, y: 0}, point2 = {x: 0, y: 0}) {\n  return Math.hypot(point2.x - point1.x, point2.y - point1.y);\n}\n\n/**\n * Add two angles together.\n * Return a positive number between 0 and 359.9999.\n */\nfunction addAngle(a = 0, b = 0) {\n  const sum = a + b;\n  let result;\n\n  if (sum > 0) {\n    result = sum % 360;\n  } else {\n    result = 360 + (sum % 360);\n  }\n  if (result === 360) result = 0;\n\n  return result;\n}\n\n/**\n * Return the shortest difference (in degrees) between two angles.\n * Only accept angles between 0 and 360.\n */\nfunction diffAngle(a = 0, b = 0) {\n  const offsetFrom180 = 180 - b;\n  const aWithOffset = addAngle(a, offsetFrom180);\n  return 180 - aWithOffset;\n}\n\n/**\n * Calculate what the new rotation of a wheel should be, so that the relative angle `targetAngle` will be at 0 degrees (north).\n * targetAngle = a value between 0 and 360.\n * direction = the direction the wheel can spin. 1 for clockwise, -1 for antiClockwise.\n */\nfunction calcWheelRotationForTargetAngle(currentRotation = 0, targetAngle = 0, direction = 1) {\n\n  let angle = ((currentRotation % 360) + targetAngle) % 360;\n\n  // Ignore tiny values.\n  // Due to floating point arithmetic, ocassionally the input angles won't add up exactly\n  // and this can push the angle slightly above 360.\n  angle = fixFloat(angle);\n\n  // Apply direction:\n  angle = ((direction === 1) ? (360 - angle) : 360 + angle) % 360;\n  angle *= direction;\n\n  return currentRotation + angle;\n}\n\nfunction isObject(v) {\n  return typeof v === 'object' && !Array.isArray(v) && v !== null;\n}\n\nfunction isNumber(n) {\n  return typeof n === 'number' && !Number.isNaN(n);\n}\n\nfunction setProp({val, isValid, errorMessage, defaultValue, action = null}) {\n  if (isValid) {\n    return (action) ? action() : val;\n  } else if (val === undefined) {\n    return defaultValue;\n  }\n  throw new Error(errorMessage);\n}\n\n/**\n * Return true if image has loaded.\n */\nfunction isImageLoaded(image) {\n  // We can detect a broken image (didn't load) by checking the natural width/height.\n  return image && image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;\n}\n\nfunction fixFloat(f = 0) {\n  return Number(f.toFixed(9));\n}\n\n/**\n * Easing function.\n */\nfunction easeSinOut(n) {\n  return Math.sin((n * Math.PI) / 2);\n}\n\n\n//# sourceURL=webpack://my-spin-wheel-project/./node_modules/spin-wheel/src/util.js?");

/***/ }),

/***/ "./node_modules/spin-wheel/src/wheel.js":
/*!**********************************************!*\
  !*** ./node_modules/spin-wheel/src/wheel.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wheel: () => (/* binding */ Wheel)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/spin-wheel/src/util.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/spin-wheel/src/constants.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ \"./node_modules/spin-wheel/src/events.js\");\n/* harmony import */ var _item_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./item.js */ \"./node_modules/spin-wheel/src/item.js\");\n\n\n\n\n\n\nclass Wheel {\n\n  /**\n   * Create the wheel inside a container Element and initialise it with props.\n   * `container` must be an Element.\n   * `props` must be an Object or null.\n   */\n  constructor(container, props = {}) {\n\n    // Validate params.\n    if (!(container instanceof Element)) throw new Error('container must be an instance of Element');\n    if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject(props) && props !== null) throw new Error('props must be an Object or null');\n\n    // Init some things:\n    this._frameRequestId = null;\n    this._rotationSpeed = 0;\n    this._rotationDirection = 1;\n    this._spinToTimeEnd = null; // Used to animate the wheel for spinTo()\n    this._lastSpinFrameTime = null; // Used to animate the wheel for spin()\n    this._isCursorOverWheel = false;\n\n    this.add(container);\n\n    // Assign default values.\n    // This avoids null exceptions when we initalise each property one-by-one in `init()`.\n    for (const i of Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel)) {\n      this['_' + i] = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel[i];\n    }\n\n    if (props) {\n      this.init(props);\n    } else {\n      this.init(_constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel);\n    }\n\n  }\n\n  /**\n   * Initialise all properties.\n   */\n  init(props = {}) {\n    this._isInitialising = true;\n\n    this.borderColor = props.borderColor;\n    this.borderWidth = props.borderWidth;\n    this.debug = props.debug;\n    this.image = props.image;\n    this.isInteractive = props.isInteractive;\n    this.itemBackgroundColors = props.itemBackgroundColors;\n    this.itemLabelAlign = props.itemLabelAlign;\n    this.itemLabelBaselineOffset = props.itemLabelBaselineOffset;\n    this.itemLabelColors = props.itemLabelColors;\n    this.itemLabelFont = props.itemLabelFont;\n    this.itemLabelFontSizeMax = props.itemLabelFontSizeMax;\n    this.itemLabelRadius = props.itemLabelRadius;\n    this.itemLabelRadiusMax = props.itemLabelRadiusMax;\n    this.itemLabelRotation = props.itemLabelRotation;\n    this.itemLabelStrokeColor = props.itemLabelStrokeColor;\n    this.itemLabelStrokeWidth = props.itemLabelStrokeWidth;\n    this.items = props.items;\n    this.lineColor = props.lineColor;\n    this.lineWidth = props.lineWidth;\n    this.pixelRatio = props.pixelRatio;\n    this.rotationSpeedMax = props.rotationSpeedMax;\n    this.radius = props.radius;\n    this.rotation = props.rotation;\n    this.rotationResistance = props.rotationResistance;\n    this.offset = props.offset;\n    this.onCurrentIndexChange = props.onCurrentIndexChange;\n    this.onRest = props.onRest;\n    this.onSpin = props.onSpin;\n    this.overlayImage = props.overlayImage;\n    this.pointerAngle = props.pointerAngle;\n  }\n\n  /**\n   * Add the wheel to the DOM and register event handlers.\n   */\n  add(container) {\n    this._canvasContainer = container;\n    this.canvas = document.createElement('canvas');\n    this._context = this.canvas.getContext('2d');\n    this._canvasContainer.append(this.canvas);\n    _events_js__WEBPACK_IMPORTED_MODULE_2__.register(this);\n    if (this._isInitialising === false) this.resize(); // Initalise the canvas's dimensions (but not when called from the constructor).\n  }\n\n  /**\n   * Remove the wheel from the DOM and unregister event handlers.\n   */\n  remove() {\n    if (this.canvas === null) return;\n    window.cancelAnimationFrame(this._frameRequestId);\n    _events_js__WEBPACK_IMPORTED_MODULE_2__.unregister(this);\n    this._canvasContainer.removeChild(this.canvas);\n    this._canvasContainer = null;\n    this.canvas = null;\n    this._context = null;\n  }\n\n  /**\n   * Resize the wheel to fit inside it's container.\n   * Call this after changing any property of the wheel that relates to it's size or position.\n   */\n  resize() {\n\n    // Set the dimensions of the canvas element to be the same as its container:\n    this.canvas.style.width = this._canvasContainer.clientWidth + 'px';\n    this.canvas.style.height = this._canvasContainer.clientHeight + 'px';\n\n    // Calc the actual pixel dimensions that will be drawn:\n    // See https://www.khronos.org/webgl/wiki/HandlingHighDPI\n    const [w, h] = [\n      this._canvasContainer.clientWidth * this.getActualPixelRatio(),\n      this._canvasContainer.clientHeight * this.getActualPixelRatio(),\n    ];\n    this.canvas.width = w;\n    this.canvas.height = h;\n\n    // Calc the size that the wheel needs to be to fit in it's container:\n    const min = Math.min(w, h);\n    const wheelSize = {\n      w: min - (min * this.offset.w),\n      h: min - (min * this.offset.h),\n    };\n    const scale = Math.min(w / wheelSize.w, h / wheelSize.h);\n    this._size = Math.max(wheelSize.w * scale, wheelSize.h * scale);\n\n    // Calculate the center of the wheel:\n    this._center = {\n      x: w / 2 + (w * this.offset.w),\n      y: h / 2 + (h * this.offset.h),\n    };\n\n    // Calculate the wheel radius:\n    this._actualRadius = (this._size / 2) * this.radius;\n\n    // Adjust the font size of labels so they all fit inside the wheel's radius:\n    this.itemLabelFontSize = this.itemLabelFontSizeMax * (this._size / _constants_js__WEBPACK_IMPORTED_MODULE_1__.baseCanvasSize);\n    this.labelMaxWidth = this._actualRadius * (this.itemLabelRadius - this.itemLabelRadiusMax);\n    for (const item of this._items) {\n      this.itemLabelFontSize = Math.min(this.itemLabelFontSize, _util_js__WEBPACK_IMPORTED_MODULE_0__.getFontSizeToFit(item.label, this.itemLabelFont, this.labelMaxWidth, this._context));\n    }\n\n    this.refresh();\n\n  }\n\n  /**\n   * Main animation loop.\n   */\n  draw(now = 0) {\n\n    this._frameRequestId = null;\n\n    const ctx = this._context;\n\n    // Clear canvas.\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.animateRotation(now);\n\n    const angles = this.getItemAngles(this._rotation);\n\n    const actualBorderWidth = this.getScaledNumber(this._borderWidth);\n\n    // Set font:\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = this.itemLabelAlign;\n    ctx.font = this.itemLabelFontSize + 'px ' + this.itemLabelFont;\n\n    ctx.save();\n\n    // Build paths:\n    for (const [i, a] of angles.entries()) {\n\n      const path = new Path2D();\n      path.moveTo(this._center.x, this._center.y);\n      path.arc(\n        this._center.x,\n        this._center.y,\n        this._actualRadius - (actualBorderWidth / 2),\n        _util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(a.start + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust),\n        _util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(a.end + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust)\n      );\n\n      this._items[i].path = path;\n\n    }\n\n    this.drawItemBackgrounds(ctx, angles);\n    this.drawItemImages(ctx, angles);\n    this.drawItemLines(ctx, angles);\n    this.drawItemLabels(ctx, angles);\n    this.drawBorder(ctx);\n    this.drawImage(ctx, this._image, false);\n    this.drawImage(ctx, this._overlayImage, true);\n    this.drawPointerLine(ctx);\n    this.drawDragEvents(ctx);\n\n    this._isInitialising = false;\n\n  }\n\n  drawItemBackgrounds(ctx, angles = []) {\n\n    for (const [i, a] of angles.entries()) {\n\n      const item = this._items[i];\n\n      ctx.fillStyle = item.backgroundColor ?? (\n        // Fall back to a value from the repeating set:\n        this._itemBackgroundColors[i % this._itemBackgroundColors.length]\n      );\n\n      ctx.fill(item.path);\n\n    }\n\n  }\n\n  drawItemImages(ctx, angles = []) {\n\n    for (const [i, a] of angles.entries()) {\n\n      const item = this._items[i];\n\n      if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isImageLoaded(item.image)) continue;\n\n      ctx.save();\n\n      ctx.clip(item.path);\n\n      const angle = a.start + ((a.end - a.start) / 2);\n\n      ctx.translate(\n        this._center.x + Math.cos(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(angle + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust)) * (this._actualRadius * item.imageRadius),\n        this._center.y + Math.sin(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(angle + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust)) * (this._actualRadius * item.imageRadius)\n      );\n\n      ctx.rotate(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(angle + item.imageRotation));\n\n      ctx.globalAlpha = item.imageOpacity;\n\n      const width = (this._size / 500) * item.image.width * item.imageScale;\n      const height = (this._size / 500) * item.image.height * item.imageScale;\n      const widthHalf = -width / 2;\n      const heightHalf = -height / 2;\n\n      ctx.drawImage(\n        item.image,\n        widthHalf,\n        heightHalf,\n        width,\n        height\n      );\n\n      ctx.restore();\n\n    }\n\n  }\n\n  drawImage(ctx, image, isOverlay = false) {\n\n    if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isImageLoaded(image)) return;\n\n    ctx.translate(\n      this._center.x,\n      this._center.y\n    );\n\n    if (!isOverlay) ctx.rotate(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(this._rotation));\n\n    // Draw the image centered and scaled to fit the wheel's container:\n    // For convenience, scale the 'normal' image to the size of the wheel radius\n    // (so a change in the wheel radius won't require the image to also be updated).\n    const size = isOverlay ? this._size : this._size * this.radius;\n    const sizeHalf = -(size / 2);\n\n    ctx.drawImage(\n      image,\n      sizeHalf,\n      sizeHalf,\n      size,\n      size\n    );\n\n    ctx.resetTransform();\n\n  }\n\n  drawPointerLine(ctx) {\n\n    if (!this.debug) return;\n\n    ctx.translate(\n      this._center.x,\n      this._center.y\n    );\n\n    ctx.rotate(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(this._pointerAngle + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust));\n\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(this._actualRadius * 2, 0);\n\n    ctx.strokeStyle = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Debugging.pointerLineColor;\n    ctx.lineWidth = this.getScaledNumber(2);\n    ctx.stroke();\n\n    ctx.resetTransform();\n\n  }\n\n  drawBorder(ctx) {\n\n    if (this._borderWidth <= 0) return;\n\n    const actualBorderWidth = this.getScaledNumber(this._borderWidth);\n    const actualBorderColor = this._borderColor || 'transparent';\n\n    ctx.beginPath();\n    ctx.strokeStyle = actualBorderColor;\n    ctx.lineWidth = actualBorderWidth;\n    ctx.arc(this._center.x, this._center.y, this._actualRadius - (actualBorderWidth / 2), 0, 2 * Math.PI);\n    ctx.stroke();\n\n    if (this.debug) {\n      const actualDebugLineWidth = this.getScaledNumber(1);\n\n      ctx.beginPath();\n      ctx.strokeStyle = ctx.strokeStyle = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Debugging.labelRadiusColor;\n      ctx.lineWidth = actualDebugLineWidth;\n      ctx.arc(this._center.x, this._center.y, this._actualRadius * this.itemLabelRadius, 0, 2 * Math.PI);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.strokeStyle = ctx.strokeStyle = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Debugging.labelRadiusColor;\n      ctx.lineWidth = actualDebugLineWidth;\n      ctx.arc(this._center.x, this._center.y, this._actualRadius * this.itemLabelRadiusMax, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n\n  }\n\n  drawItemLines(ctx, angles = []) {\n\n    if (this._lineWidth <= 0) return;\n\n    const actualLineWidth = this.getScaledNumber(this._lineWidth);\n    const actualBorderWidth = this.getScaledNumber(this._borderWidth);\n\n    ctx.translate(\n      this._center.x,\n      this._center.y\n    );\n\n    for (const angle of angles) {\n      ctx.rotate(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(angle.start + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust));\n\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(this._actualRadius - actualBorderWidth, 0);\n\n      ctx.strokeStyle = this.lineColor;\n      ctx.lineWidth = actualLineWidth;\n      ctx.stroke();\n\n      ctx.rotate(-_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(angle.start + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust));\n    }\n\n    ctx.resetTransform();\n\n  }\n\n  drawItemLabels(ctx, angles = []) {\n\n    const actualItemLabelBaselineOffset = this.itemLabelFontSize * -this.itemLabelBaselineOffset;\n    const actualDebugLineWidth = this.getScaledNumber(1);\n    const actualLabelStrokeWidth = this.getScaledNumber(this._itemLabelStrokeWidth * 2);\n\n    for (const [i, a] of angles.entries()) {\n\n      const item = this._items[i];\n\n      const actualLabelColor = item.labelColor\n        || (this._itemLabelColors[i % this._itemLabelColors.length] // Fall back to a value from the repeating set.\n        || 'transparent'); // Handle empty string/undefined.\n\n      if (item.label.trim() === '' || actualLabelColor === 'transparent') continue;\n\n      ctx.save();\n\n      ctx.clip(item.path);\n\n      const angle = a.start + ((a.end - a.start) / 2);\n\n      ctx.translate(\n        this._center.x + Math.cos(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(angle + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust)) * (this._actualRadius * this.itemLabelRadius),\n        this._center.y + Math.sin(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(angle + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust)) * (this._actualRadius * this.itemLabelRadius)\n      );\n\n      ctx.rotate(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(angle + _constants_js__WEBPACK_IMPORTED_MODULE_1__.arcAdjust));\n\n      ctx.rotate(_util_js__WEBPACK_IMPORTED_MODULE_0__.degRad(this.itemLabelRotation));\n\n      if (this.debug) {\n        // Draw the outline of the label:\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(-this.labelMaxWidth, 0);\n\n        ctx.strokeStyle = _constants_js__WEBPACK_IMPORTED_MODULE_1__.Debugging.labelOutlineColor;\n        ctx.lineWidth = actualDebugLineWidth;\n        ctx.stroke();\n\n        ctx.strokeRect(0, -this.itemLabelFontSize / 2, -this.labelMaxWidth, this.itemLabelFontSize);\n      }\n\n      if (this._itemLabelStrokeWidth > 0) {\n        ctx.lineWidth = actualLabelStrokeWidth;\n        ctx.strokeStyle = this._itemLabelStrokeColor;\n        ctx.lineJoin = 'round';\n        ctx.strokeText(item.label, 0, actualItemLabelBaselineOffset);\n      }\n\n      ctx.fillStyle = actualLabelColor;\n      ctx.fillText(item.label, 0, actualItemLabelBaselineOffset);\n\n      ctx.restore();\n\n    }\n\n  }\n\n  drawDragEvents(ctx) {\n\n    if (!this.debug || !this.dragEvents?.length) return;\n\n    const dragEventsReversed = [...this.dragEvents].reverse();\n    const actualLineWidth = this.getScaledNumber(0.5);\n    const actualCircleDiameter = this.getScaledNumber(4);\n\n    for (const [i, event] of dragEventsReversed.entries()) {\n      const percent = (i / this.dragEvents.length) * 100;\n      ctx.beginPath();\n      ctx.arc(event.x, event.y, actualCircleDiameter, 0, 2 * Math.PI);\n      ctx.fillStyle = `hsl(${_constants_js__WEBPACK_IMPORTED_MODULE_1__.Debugging.dragEventHue},100%,${percent}%)`;\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = actualLineWidth;\n      ctx.fill();\n      ctx.stroke();\n    }\n\n  }\n\n  animateRotation(now = 0) {\n\n    // For spinTo()\n    if (this._spinToTimeEnd !== null) {\n\n      // Check if we should end the animation:\n      if (now >= this._spinToTimeEnd) {\n        this.rotation = this._spinToEndRotation;\n        this._spinToTimeEnd = null;\n        this.raiseEvent_onRest();\n        return;\n      }\n\n      const duration = this._spinToTimeEnd - this._spinToTimeStart;\n      let delta = (now - this._spinToTimeStart) / duration;\n      delta = (delta < 0)? 0 : delta; // Frame time may be before the start time.\n      const distance = this._spinToEndRotation - this._spinToStartRotation;\n\n      this.rotation = this._spinToStartRotation + distance * this._spinToEasingFunction(delta);\n\n      this.refresh();\n\n      return;\n\n    }\n\n    // For spin()\n    if (this._lastSpinFrameTime !== null) {\n\n      const delta = now - this._lastSpinFrameTime;\n\n      if (delta > 0) {\n\n        this.rotation += ((delta / 1000) * this._rotationSpeed) % 360; // TODO: very small rounding errors can accumulative here.\n        this._rotationSpeed = this.getRotationSpeedPlusDrag(delta);\n\n        // Check if we should end the animation:\n        if (this._rotationSpeed === 0) {\n          this.raiseEvent_onRest();\n          this._lastSpinFrameTime = null;\n        } else {\n          this._lastSpinFrameTime = now;\n        }\n\n      }\n\n      this.refresh();\n\n      return;\n\n    }\n\n  }\n\n  getRotationSpeedPlusDrag(delta = 0) {\n\n    // Simulate drag:\n    const newRotationSpeed = this._rotationSpeed + ((this.rotationResistance * (delta / 1000)) * this._rotationDirection);\n\n    // Stop rotation once speed reaches 0.\n    // Otherwise the wheel could rotate in the opposite direction next frame.\n    if ((this._rotationDirection === 1 && newRotationSpeed < 0) || (this._rotationDirection === -1 && newRotationSpeed >= 0)) {\n      return 0;\n    }\n\n    return newRotationSpeed;\n\n  }\n\n  /**\n   * Spin the wheel by setting `rotationSpeed`.\n   * The wheel will immediately start spinning, and slow down over time depending on the value of `rotationResistance`.\n   * A positive number will spin clockwise, a negative number will spin anticlockwise.\n   */\n  spin(rotationSpeed = 0) {\n    if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(rotationSpeed)) throw new Error('rotationSpeed must be a number');\n    this.dragEvents = [];\n    this.beginSpin(rotationSpeed, 'spin');\n  }\n\n  /**\n   * Spin the wheel to a particular rotation.\n   * The animation will occur over the provided `duration` (milliseconds).\n   * The animation can be adjusted by providing an optional `easingFunction` which accepts a single parameter n, where n is between 0 and 1 inclusive.\n   * If no easing function is provided, the default easeSinOut will be used.\n   * For example easing functions see [easing-utils](https://github.com/AndrewRayCode/easing-utils).\n   */\n  spinTo(rotation = 0, duration = 0, easingFunction = null) {\n\n    if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(rotation)) throw new Error('Error: rotation must be a number');\n    if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(duration)) throw new Error('Error: duration must be a number');\n\n    this.stop();\n\n    this.dragEvents = [];\n\n    this.animate(rotation, duration, easingFunction);\n\n    this.raiseEvent_onSpin({method: 'spinto', targetRotation: rotation, duration});\n\n  }\n\n  /**\n   * Spin the wheel to a particular item.\n   * The animation will occur over the provided `duration` (milliseconds).\n   * If `spinToCenter` is true, the wheel will spin to the center of the item, otherwise the wheel will spin to a random angle inside the item.\n   * `numberOfRevolutions` controls how many times the wheel will rotate a full 360 degrees before resting on the item.\n   * The animation can be adjusted by providing an optional `easingFunction` which accepts a single parameter n, where n is between 0 and 1 inclusive.\n   * If no easing function is provided, the default easeSinOut will be used.\n   * For example easing functions see [easing-utils](https://github.com/AndrewRayCode/easing-utils).\n   */\n  spinToItem(itemIndex = 0, duration = 0, spinToCenter = true, numberOfRevolutions = 1, direction = 1, easingFunction = null) {\n\n    this.stop();\n\n    this.dragEvents = [];\n\n    const itemAngle = spinToCenter ? this.items[itemIndex].getCenterAngle() : this.items[itemIndex].getRandomAngle();\n\n    let newRotation = _util_js__WEBPACK_IMPORTED_MODULE_0__.calcWheelRotationForTargetAngle(this.rotation, itemAngle - this._pointerAngle, direction);\n    newRotation += ((numberOfRevolutions * 360) * direction);\n\n    this.animate(newRotation, duration, easingFunction);\n\n    this.raiseEvent_onSpin({method: 'spintoitem', targetItemIndex: itemIndex, targetRotation: newRotation, duration});\n\n  }\n\n  animate(newRotation, duration, easingFunction) {\n    this._spinToStartRotation = this.rotation;\n    this._spinToEndRotation = newRotation;\n    this._spinToTimeStart = performance.now();\n    this._spinToTimeEnd = this._spinToTimeStart + duration;\n    this._spinToEasingFunction = easingFunction || _util_js__WEBPACK_IMPORTED_MODULE_0__.easeSinOut;\n    this.refresh();\n  }\n\n  /**\n   * Immediately stop the wheel from spinning, regardless of which method was used to spin it.\n   */\n  stop() {\n\n    // Stop the wheel if it was spun via `spinTo()`.\n    this._spinToTimeEnd = null;\n\n    // Stop the wheel if it was spun via `spin()`.\n    this._rotationSpeed = 0;\n    this._lastSpinFrameTime = null;\n\n  }\n\n  /**\n   * Return n scaled to the size of the canvas.\n   */\n  getScaledNumber(n) {\n     return (n / _constants_js__WEBPACK_IMPORTED_MODULE_1__.baseCanvasSize) * this._size;\n  }\n\n  getActualPixelRatio() {\n    return (this._pixelRatio !== 0) ? this._pixelRatio : window.devicePixelRatio;\n  }\n\n  /**\n   * Return true if the given point is inside the wheel.\n   */\n  wheelHitTest(point = {x:0, y:0}) {\n    const p = _util_js__WEBPACK_IMPORTED_MODULE_0__.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.isPointInCircle(p, this._center.x, this._center.y, this._actualRadius);\n  }\n\n  /**\n   * Refresh the cursor state.\n   * Call this after the pointer moves.\n   */\n  refreshCursor() {\n\n    if (this.isInteractive) {\n\n      if (this.isDragging) {\n        this.canvas.style.cursor = 'grabbing';\n        return;\n      }\n\n      if (this._isCursorOverWheel) {\n        this.canvas.style.cursor = 'grab';\n        return;\n      }\n\n    }\n\n    this.canvas.style.cursor = '';\n\n  }\n\n  /**\n   * Get the angle (in degrees) of the given point from the center of the wheel.\n   * 0 is north.\n   */\n  getAngleFromCenter(point = {x:0, y:0}) {\n    return (_util_js__WEBPACK_IMPORTED_MODULE_0__.getAngle(this._center.x, this._center.y, point.x, point.y) + 90) % 360;\n  }\n\n  /**\n   * Get the index of the item that the Pointer is pointing at.\n   * An item is considered \"current\" if `pointerAngle` is between it's start angle (inclusive)\n   * and it's end angle (exclusive).\n   */\n  getCurrentIndex() {\n    return this._currentIndex;\n  }\n\n  /**\n   * Calculate and set `currentIndex`\n   */\n  refreshCurrentIndex(angles = []) {\n    if (this._items.length === 0) this._currentIndex = -1;\n\n    for (const [i, a] of angles.entries()) {\n\n      if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.isAngleBetween(this._pointerAngle, a.start % 360, a.end % 360)) continue;\n\n      if (this._currentIndex === i) break;\n\n      this._currentIndex = i;\n\n      if (!this._isInitialising) this.raiseEvent_onCurrentIndexChange();\n\n      break;\n\n    }\n  }\n\n  /**\n   * Return an array of objects containing the start angle (inclusive) and end angle (inclusive) of each item.\n   */\n  getItemAngles(initialRotation = 0) {\n\n    let weightSum = 0;\n    for (const i of this.items) {\n      weightSum += i.weight;\n    }\n    const weightedItemAngle = 360 / weightSum;\n\n    let itemAngle;\n    let lastItemAngle = initialRotation;\n    const angles = [];\n\n    for (const item of this._items) {\n      itemAngle = item.weight * weightedItemAngle;\n      angles.push({\n        start: lastItemAngle,\n        end: lastItemAngle + itemAngle,\n      });\n      lastItemAngle += itemAngle;\n    }\n\n    // Ensure the difference between last angle.end and first angle.start is exactly 360 degrees.\n    // Sometimes floating point arithmetic pushes the end value past 360 degrees by\n    // a very small amount, which causes issues when calculating `currentIndex`.\n    if (this._items.length > 1) {\n      angles[angles.length - 1].end = angles[0].start + 360;\n    }\n\n    return angles;\n\n  }\n\n  /**\n   * Schedule a redraw of the wheel on the canvas.\n   * Call this after changing any property of the wheel that relates to it's appearance.\n   */\n  refresh() {\n    if (this._frameRequestId === null) {\n      this._frameRequestId = window.requestAnimationFrame(t => this.draw(t));\n    }\n  }\n\n  limitSpeed(speed = 0, max = 0) {\n    // Max is always a positive number, but speed may be positive or negative.\n    const newSpeed = Math.min(speed, max);\n    return Math.max(newSpeed, -max);\n  }\n\n  beginSpin(speed = 0, spinMethod = '') {\n    this.stop();\n\n    this._rotationSpeed = this.limitSpeed(speed, this._rotationSpeedMax);\n    this._lastSpinFrameTime = performance.now();\n\n    this._rotationDirection = (this._rotationSpeed >= 0) ? 1 : -1; // 1 for clockwise or stationary, -1 for anticlockwise.\n\n    if (this._rotationSpeed !== 0) {\n      this.raiseEvent_onSpin({\n        method: spinMethod,\n        rotationSpeed: this._rotationSpeed,\n        rotationResistance: this._rotationResistance,\n      });\n    }\n\n    this.refresh();\n  }\n\n  refreshAriaLabel() {\n    // See https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/img_role\n    this.canvas.setAttribute('role', 'img');\n    const wheelDescription = (this.items.length >= 2) ? ` The wheel has ${this.items.length} slices.` : '';\n    this.canvas.setAttribute('aria-label', 'An image of a spinning prize wheel.' + wheelDescription);\n  }\n\n  /**\n   * The color of the line around the circumference of the wheel.\n   */\n  get borderColor() {\n    return this._borderColor;\n  }\n  set borderColor(val) {\n    this._borderColor = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.borderColor must be a string',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.borderColor,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The width (in pixels) of the line around the circumference of the wheel.\n   */\n  get borderWidth() {\n    return this._borderWidth;\n  }\n  set borderWidth(val) {\n    this._borderWidth = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.borderWidth must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.borderWidth,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * Show debugging info.\n   * This is particularly helpful when fine-tuning labels.\n   */\n  get debug() {\n    return this._debug;\n  }\n  set debug(val) {\n    this._debug = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'boolean',\n      errorMessage: 'Wheel.debug must be a boolean',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.debug,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The url of an image that will be drawn over the center of the wheel which will rotate with the wheel.\n   * It will be automatically scaled to fit `radius`.\n   */\n  get image() {\n    return this._image?.src ?? null;\n  }\n  set image(val) {\n    this._image = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'string' || val === null,\n      errorMessage: 'Wheel.image must be a url (string) or null',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.image,\n      action: () => {\n        if (val === null) return null;\n        const v = new Image();\n        v.src = val;\n        v.onload = e => this.refresh();\n        return v;\n      },\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * Allow the user to spin the wheel using click-drag/touch-flick.\n   * User interaction will only be detected within the bounds of `Wheel.radius`.\n   */\n  get isInteractive() {\n    return this._isInteractive;\n  }\n  set isInteractive(val) {\n    this._isInteractive = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'boolean',\n      errorMessage: 'Wheel.isInteractive must be a boolean',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.isInteractive,\n    });\n\n    this.refreshCursor(); // Reset the cursor in case the wheel is currently being dragged.\n  }\n\n  /**\n   * The repeating pattern of background colors for all items.\n   * Overridden by `Item.backgroundColor`.\n   * Example: `['#fff','#000']`.\n   */\n  get itemBackgroundColors() {\n    return this._itemBackgroundColors;\n  }\n  set itemBackgroundColors(val) {\n    this._itemBackgroundColors = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: Array.isArray(val),\n      errorMessage: 'Wheel.itemBackgroundColors must be an array',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemBackgroundColors,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The alignment of all item labels.\n   * Accepted values: `'left'`,`'center'`,`'right'`.\n   */\n  get itemLabelAlign() {\n    return this._itemLabelAlign;\n  }\n  set itemLabelAlign(val) {\n    this._itemLabelAlign = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.itemLabelAlign must be a string',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelAlign,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The offset of the baseline (or line height) of all item labels (as a percent of the label's height).\n   */\n  get itemLabelBaselineOffset() {\n    return this._itemLabelBaselineOffset;\n  }\n  set itemLabelBaselineOffset(val) {\n    this._itemLabelBaselineOffset = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.itemLabelBaselineOffset must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelBaselineOffset,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The repeating pattern of colors for all item labels.\n   * Overridden by `Item.labelColor`.\n   * Example: `['#fff','#000']`.\n   */\n  get itemLabelColors() {\n    return this._itemLabelColors;\n  }\n  set itemLabelColors(val) {\n    this._itemLabelColors = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: Array.isArray(val),\n      errorMessage: 'Wheel.itemLabelColors must be an array',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelColors,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The font family for all item labels.\n   * Overridden by `Item.labelFont`.\n   * Example: `'sans-serif'`.\n   */\n  get itemLabelFont() {\n    return this._itemLabelFont;\n  }\n  set itemLabelFont(val) {\n    this._itemLabelFont = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.itemLabelFont must be a string',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelFont,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The maximum font size (in pixels) for all item labels.\n   */\n  get itemLabelFontSizeMax() {\n    return this._itemLabelFontSizeMax;\n  }\n  set itemLabelFontSizeMax(val) {\n    this._itemLabelFontSizeMax = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.itemLabelFontSizeMax must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelFontSizeMax,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The point along the radius (as a percent, starting from the center of the wheel)\n   * to start drawing all item labels.\n   */\n  get itemLabelRadius() {\n    return this._itemLabelRadius;\n  }\n  set itemLabelRadius(val) {\n    this._itemLabelRadius = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.itemLabelRadius must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelRadius,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The point along the radius (as a percent, starting from the center of the wheel)\n   * to calculate the maximum font size for all item labels.\n   */\n  get itemLabelRadiusMax() {\n    return this._itemLabelRadiusMax;\n  }\n  set itemLabelRadiusMax(val) {\n    this._itemLabelRadiusMax = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.itemLabelRadiusMax must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelRadiusMax,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The rotation of all item labels.\n   * Use this in combination with `itemLabelAlign` to flip the labels `180°`.\n   */\n  get itemLabelRotation() {\n    return this._itemLabelRotation;\n  }\n  set itemLabelRotation(val) {\n    this._itemLabelRotation = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.itemLabelRotation must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelRotation,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The color of the stroke applied to the outside of the label text.\n   */\n  get itemLabelStrokeColor() {\n    return this._itemLabelStrokeColor;\n  }\n  set itemLabelStrokeColor(val) {\n    this._itemLabelStrokeColor = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.itemLabelStrokeColor must be a string',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelStrokeColor,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The width of the stroke applied to the outside of the label text.\n   */\n  get itemLabelStrokeWidth() {\n    return this._itemLabelStrokeWidth;\n  }\n  set itemLabelStrokeWidth(val) {\n    this._itemLabelStrokeWidth = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.itemLabelStrokeWidth must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.itemLabelStrokeWidth,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The items to show on the wheel.\n   */\n  get items() {\n    return this._items;\n  }\n  set items(val) {\n    this._items = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: Array.isArray(val),\n      errorMessage: 'Wheel.items must be an array of Items',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.items,\n      action: () => {\n        const v = [];\n        for (const item of val) {\n          v.push(new _item_js__WEBPACK_IMPORTED_MODULE_3__.Item(this, {\n            backgroundColor: item.backgroundColor,\n            image: item.image,\n            imageRadius: item.imageRadius,\n            imageRotation: item.imageRotation,\n            imageScale: item.imageScale,\n            label: item.label,\n            labelColor: item.labelColor,\n            value: item.value,\n            weight: item.weight,\n          }));\n        }\n        return v;\n      },\n    });\n\n    this.refreshAriaLabel();\n    this.refreshCurrentIndex(this.getItemAngles(this._rotation));\n    this.resize(); // Refresh item label font size.\n  }\n\n  /**\n   * The color of the lines between the items.\n   */\n  get lineColor() {\n    return this._lineColor;\n  }\n  set lineColor(val) {\n    this._lineColor = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.lineColor must be a string',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.lineColor,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The width (in pixels) of the lines between the items.\n   */\n  get lineWidth() {\n    return this._lineWidth;\n  }\n  set lineWidth(val) {\n    this._lineWidth = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.lineWidth must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.lineWidth,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The offset of the wheel relative to it's center (as a percent of the wheel's diameter).\n   */\n  get offset() {\n    return this._offset;\n  }\n  set offset(val) {\n    this._offset = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isObject(val),\n      errorMessage: 'Wheel.offset must be an object',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.offset,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The callback for the `onCurrentIndexChange` event.\n   */\n  get onCurrentIndexChange() {\n    return this._onCurrentIndexChange;\n  }\n  set onCurrentIndexChange(val) {\n    this._onCurrentIndexChange = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'function' || val === null,\n      errorMessage: 'Wheel.onCurrentIndexChange must be a function or null',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.onCurrentIndexChange,\n    });\n  }\n\n  /**\n   * The callback for the `onRest` event.\n   */\n  get onRest() {\n    return this._onRest;\n  }\n  set onRest(val) {\n    this._onRest = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'function' || val === null,\n      errorMessage: 'Wheel.onRest must be a function or null',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.onRest,\n    });\n  }\n\n  /**\n   * The callback for the `onSpin` event.\n   */\n  get onSpin() {\n    return this._onSpin;\n  }\n  set onSpin(val) {\n    this._onSpin = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'function' || val === null,\n      errorMessage: 'Wheel.onSpin must be a function or null',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.onSpin,\n    });\n  }\n\n  /**\n   * The url of an image that will be drawn over the center of the wheel which will not rotate with the wheel.\n   * It will be automatically scaled to fit the container's smallest dimension.\n   * Use this to draw decorations around the wheel, such as a stand or pointer.\n   */\n  get overlayImage() {\n    return this._overlayImage?.src ?? null;\n  }\n  set overlayImage(val) {\n    this._overlayImage = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: typeof val === 'string' || val === null,\n      errorMessage: 'Wheel.overlayImage must be a url (string) or null',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.overlayImage,\n      action: () => {\n        if (val === null) return null;\n        const v = new Image();\n        v.src = val;\n        v.onload = e => this.refresh();\n        return v;\n      },\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The pixel ratio used to render the wheel.\n   * Values above 0 will produce a sharper image at the cost of performance.\n   * A value of `0` will cause the pixel ratio to be automatically determined using `window.devicePixelRatio`.\n   */\n  get pixelRatio() {\n    return this._pixelRatio;\n  }\n  set pixelRatio(val) {\n    this._pixelRatio = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.pixelRatio must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.pixelRatio,\n    });\n    this.dragEvents = [];\n    this.resize();\n  }\n\n  /**\n   * The angle of the Pointer which is used to determine the `currentIndex` (or the \"winning\" item).\n   */\n  get pointerAngle() {\n    return this._pointerAngle;\n  }\n  set pointerAngle(val) {\n    this._pointerAngle = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val) && val >= 0,\n      errorMessage: 'Wheel.pointerAngle must be a number between 0 and 360',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.pointerAngle,\n      action: () => val % 360,\n    });\n\n    if (this.debug) this.refresh();\n  }\n\n  /**\n   * The radius of the wheel (as a percent of the container's smallest dimension).\n   */\n  get radius() {\n    return this._radius;\n  }\n  set radius(val) {\n    this._radius = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.radius must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.radius,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The rotation (angle in degrees) of the wheel.\n   * `0` is north.\n   * The first item will be drawn clockwise from this point.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(val) {\n    this._rotation = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.rotation must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.rotation,\n    });\n\n    this.refreshCurrentIndex(this.getItemAngles(this._rotation));\n    this.refresh();\n  }\n\n  /**\n   * The amount that `rotationSpeed` will be reduced by every second.\n   * Only in effect when `rotationSpeed !== 0`.\n   * Set to `0` to spin the wheel infinitely.\n   */\n  get rotationResistance() {\n    return this._rotationResistance;\n  }\n  set rotationResistance(val) {\n    this._rotationResistance = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val),\n      errorMessage: 'Wheel.rotationResistance must be a number',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.rotationResistance,\n    });\n  }\n\n  /**\n   * (Readonly) How far (angle in degrees) the wheel will spin every 1 second.\n   * A positive number means the wheel is spinning clockwise, a negative number means anticlockwise, and `0` means the wheel is not spinning.\n   */\n  get rotationSpeed() {\n    return this._rotationSpeed;\n  }\n\n  /**\n   * The maximum value for `rotationSpeed` (ignoring the wheel's spin direction).\n   * The wheel will not spin faster than this value in any direction.\n   */\n  get rotationSpeedMax() {\n    return this._rotationSpeedMax;\n  }\n  set rotationSpeedMax(val) {\n    this._rotationSpeedMax = _util_js__WEBPACK_IMPORTED_MODULE_0__.setProp({\n      val,\n      isValid: _util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(val) && val >= 0,\n      errorMessage: 'Wheel.rotationSpeedMax must be a number >= 0',\n      defaultValue: _constants_js__WEBPACK_IMPORTED_MODULE_1__.Defaults.wheel.rotationSpeedMax,\n    });\n  }\n\n  /**\n   * Enter the drag state.\n   */\n  dragStart(point = {x:0, y:0}) {\n\n    const p = _util_js__WEBPACK_IMPORTED_MODULE_0__.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n\n    this.isDragging = true;\n\n    this.stop(); // Interrupt `spinTo()`\n\n    this.dragEvents = [{\n      distance: 0,\n      x: p.x,\n      y: p.y,\n      now:performance.now(),\n    }];\n\n    this.refreshCursor();\n\n  }\n\n  dragMove(point = {x:0, y:0}) {\n\n    const p = _util_js__WEBPACK_IMPORTED_MODULE_0__.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n    const a = this.getAngleFromCenter(p);\n\n    const lastDragPoint = this.dragEvents[0];\n    const lastAngle = this.getAngleFromCenter(lastDragPoint);\n    const angleSinceLastMove = _util_js__WEBPACK_IMPORTED_MODULE_0__.diffAngle(lastAngle, a);\n\n    this.dragEvents.unshift({\n      distance: angleSinceLastMove,\n      x: p.x,\n      y: p.y,\n      now:performance.now(),\n    });\n\n    // Retain max 40 drag events.\n    if (this.debug && this.dragEvents.length >= 40) this.dragEvents.pop();\n\n    // Snap the wheel to the new rotation.\n    this.rotation += angleSinceLastMove; // TODO: can we apply easing here so it looks nicer?\n\n  }\n\n  /**\n   * Exit the drag state.\n   * Set the rotation speed so the wheel continues to spin in the same direction.\n   */\n  dragEnd() {\n\n    this.isDragging = false;\n\n    // Calc the drag distance:\n    let dragDistance = 0;\n    const now = performance.now();\n\n    for (const [i, event] of this.dragEvents.entries()) {\n\n      if (!this.isDragEventTooOld(now, event)) {\n        dragDistance += event.distance;\n        continue;\n      }\n\n      // Exclude old events:\n      this.dragEvents.length = i;\n      if (this.debug) this.refresh(); // Redraw drag events after trimming the array.\n      break;\n\n    }\n\n    this.refreshCursor();\n\n    if (dragDistance === 0) return;\n\n    this.beginSpin(dragDistance * (1000 / _constants_js__WEBPACK_IMPORTED_MODULE_1__.dragCapturePeriod), 'interact');\n\n  }\n\n  isDragEventTooOld(now = 0, event = {}) {\n    return (now - event.now) > _constants_js__WEBPACK_IMPORTED_MODULE_1__.dragCapturePeriod;\n  }\n\n  raiseEvent_onCurrentIndexChange(data = {}) {\n    this.onCurrentIndexChange?.({\n      type: 'currentIndexChange',\n      currentIndex: this._currentIndex,\n      ...data,\n    });\n  }\n\n  raiseEvent_onRest(data = {}) {\n    this.onRest?.({\n      type: 'rest',\n      currentIndex: this._currentIndex,\n      rotation: this._rotation,\n      ...data,\n    });\n  }\n\n  raiseEvent_onSpin(data = {}) {\n    this.onSpin?.({\n      type: 'spin',\n      ...data,\n    });\n  }\n\n}\n\n\n//# sourceURL=webpack://my-spin-wheel-project/./node_modules/spin-wheel/src/wheel.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;